# Instruções de Implementação – Plataforma de Revenda de Veículos (Tech Challenge – Fase 2)

Este documento consolida o entendimento do escopo, decisões arquiteturais mínimas, padrões de qualidade, infraestrutura (Docker/Kubernetes) e CI/CD (GitHub + Docker Hub) necessários para entregar a solução.

## Escopo funcional
- Cadastrar veículo: marca, modelo, ano, cor, preço.
- Editar dados do veículo.
- Efetuar venda: CPF do comprador, data da venda (e preço de venda, se aplicável).
- Listar veículos à venda (status: disponível), ordenados por preço ascendente.
- Listar veículos vendidos (status: vendido), ordenados por preço ascendente.
- Webhook de pagamento: a partir de um código de pagamento, receber status efetivado/cancelado.

Observações:
- Campos e fluxos adicionais podem ser necessários; a modelagem deve cobrir gaps funcionais e técnicos.
- Documentação dos endpoints via OpenAPI/Swagger é obrigatória.

## Requisitos implícitos e regras de negócio
- Identificador único para veículo (id) e controle de status: AVAILABLE | SOLD.
- Validações mínimas: preço > 0; ano dentro de faixa aceitável (ex.: ≥ 1900 e ≤ ano atual+1); CPF válido; campos obrigatórios presentes.
- Venda somente se o veículo estiver AVAILABLE; ao vender, registrar comprador, data, valor e vincular código de pagamento quando existir.
- Paginação e filtros básicos nas listagens (por status), com ordenação por preço asc.
- Idempotência/segurança no webhook: aceitar reentregas; validar assinatura/segredo do provedor (quando houver).

## Modelo de dados (mínimo recomendado)
- Vehicle: { id, brand, model, year, color, price, status, createdAt, updatedAt }
- Sale: { id, vehicleId, buyerCpf, saleDate, salePrice, paymentCode?, paymentStatus?, createdAt }
- PaymentStatus (enum): PENDING | PAID | CANCELED. O webhook atualiza paymentStatus a partir do paymentCode.

Banco de dados: relacional (MySQL). Tabelas com índices em (status, price) para listagens.

## API (contratos de alto nível)
- POST /vehicles – cria veículo. 201 com payload do veículo criado.
- PUT /vehicles/{id} – edita campos permitidos enquanto AVAILABLE.
- GET /vehicles?status=AVAILABLE&sort=price,asc – lista disponíveis (paginação: page, size).
- GET /vehicles?status=SOLD&sort=price,asc – lista vendidos (paginação idem).
- POST /vehicles/{id}/sell – efetiva venda (buyerCpf, saleDate, salePrice, paymentCode?). Retorna venda e veículo com status atualizado.
- POST /payments/webhook – body: { paymentCode, status } onde status ∈ {PAID, CANCELED}. Idempotente (retornar 200 em repetições coerentes).

Erros padronizados (4xx/5xx) com código, mensagem e detalhes. Health check: GET /health.

## Documentação (OpenAPI/Swagger)
- Manter especificação OpenAPI 3.x (YAML/JSON) versionada no repositório e exposta em /docs (ou /swagger) no runtime.
- Incluir exemplos de requests/responses e schema de erros.

## Arquitetura e qualidade
- Clean Architecture + SOLID (camadas):
  - Domain: entidades, regras, casos de uso.
  - Application/Use Cases: orquestra fluxos; portas (interfaces) para repositórios e serviços externos.
  - Infrastructure: adapters (ORM/DB, HTTP, mensageria), repositórios concretos.
  - Interface (API): controllers/routers, DTOs, validação, autenticação (se houver).
- Boas práticas: DTOs com validação, mapeamento de erros, logging estruturado (correlação por request-id), testes unitários (casos de uso) e integração (API + DB).

## Segurança e compliance
- Não versionar segredos. Usar variáveis de ambiente e Secrets no Kubernetes.
- Sanitizar logs; validar inputs; CORS configurado para os domínios do frontend.
- Webhook protegido por segredo/cabeçalho de autenticação do provedor quando aplicável.

## Contêineres e execução local
- Dockerfile multi-stage (build → runtime) e .dockerignore.
- docker-compose.yml com: app (FastAPI), db (MySQL 8.x), e exposição de porta da API.
- Arquivos de ambiente: .env (local) e .env.example (modelo sem segredos).
- Notas Windows PowerShell: usar `;` para encadear comandos e variáveis de ambiente com `$env:VAR`.

Implementações realizadas:
- requirements.txt com dependências (FastAPI, SQLAlchemy, PyMySQL, etc.).
- Estrutura inicial do app (`app/`): config, domain (models, schemas), infrastructure (db), routers (vehicles, payments), main e init_db.
- Dockerfile e docker-compose.yml (app + MySQL, healthcheck e init de schema).
- `.env.example` e `.gitignore` adicionados.
- README inicial com instruções de uso local e deploy.
- `.dockerignore` adicionado.
- Startup event cria schema automaticamente (substituível por Alembic em produção).

## Kubernetes (cluster alvo)
- Cluster: 192.168.1.112 (Ubuntu 24). Acesso provido fora do repositório. Não commitar usuário/senha.
- Manifests versionados no repositório, por ambiente (ex.: k8s/base e k8s/overlays/prod) ou simples em k8s/.
- Recursos mínimos:
  - Namespace dedicado.
  - Banco: MySQL como StatefulSet com PVC e Service dedicado.
  - API: Deployment (réplicas ≥ 2), liveness/readiness probes, requests/limits de CPU/Mem.
  - Services (ClusterIP) para MySQL e API.
  - ConfigMap: variáveis não sensíveis (APP_ENV, LOG_LEVEL, DB_HOST, DB_NAME).
  - Secrets: variáveis sensíveis (DB_USER, DB_PASSWORD, DB_ROOT_PASSWORD, JWT_SECRET, WEBHOOK_SECRET). Usar base64 e restringir acesso RBAC.
  - Opcional: Ingress/Nginx para expor HTTP externamente.
  - imagePullSecrets para autenticar no Docker Hub, quando necessário.

Implementações realizadas (manifests em `k8s/`):
- `namespace.yaml`: namespace fiap-vehicles.
- `mysql-secret.yaml`: segredos do MySQL (ajustar valores em produção).
- `mysql-statefulset.yaml`: StatefulSet + Service (headless) para MySQL com PVC.
- `api.yaml`: ConfigMap, Secret da API, Deployment (2 réplicas com probes) e Service ClusterIP.

## CI/CD – Status
- Workflow criado em `.github/workflows/ci-cd.yml` com estágios: build/test, build/push Docker Hub, deploy (kubectl apply).
- Segredos esperados no GitHub: DOCKERHUB_USERNAME, DOCKERHUB_TOKEN, KUBE_CONFIG.

## Documentação de arquitetura
- Diagrama `ARCHITECTURE.md` (Mermaid) adicionado.

Observações de acesso:
- Armazenar credenciais do cluster como segredo no GitHub (ex.: KUBE_CONFIG ou K8S_SERVER/K8S_USER/K8S_PASSWORD). Nunca em texto plano no repo.
- Se usar GitHub Actions para deploy, configurar kubectl/context via secrets.

## GitHub (código) e Docker Hub (imagens)
- Repositório: GitHub (padrão main + PRs; proteção de branch; revisão obrigatória).
- Tags de versão: semânticas (vX.Y.Z) ou release-<data> para entregáveis.
- Imagens: Docker Hub em um repositório dedicado (ex.: docker.io/<org>/<app>). Tags: commit SHA, branch, latest para main.

## CI/CD (sugestão de pipeline)
- Jobs:
  1) Lint + testes
  2) Build imagem Docker e push para Docker Hub
  3) Geração/publicação do OpenAPI estático (artefato)
  4) Deploy no Kubernetes (kubectl apply -f k8s/) condicionado a branch/tag
- Segredos necessários no GitHub:
  - DOCKERHUB_USERNAME, DOCKERHUB_TOKEN
  - KUBE_CONFIG (ou K8S_SERVER, K8S_USER, K8S_PASSWORD) – manter fora do repo
  - WEBHOOK_SECRET, DB_PASSWORD (para manifestos/Secrets)

## Entregáveis solicitados
- PDF com links para:
  - Repositório GitHub do código-fonte
  - Vídeo demonstrando aplicação e infraestrutura Kubernetes em funcionamento
- Conteúdo do repositório:
  - README.md: visão geral, como rodar localmente, como testar, decisões técnicas
  - Código-fonte implementando todos os requisitos com Clean Architecture + SOLID
  - Dockerfile + docker-compose.yml
  - Manifests Kubernetes (Deployment, Service, ConfigMap, Secret, Ingress opcional)

## Critérios de aceite (mínimos)
- CRUD e venda funcionam; alterações de status corretas.
- Listagens retornam ordenação por preço ascendente; paginam e filtram por status.
- Webhook atualiza paymentStatus idempotentemente.
- Documentação OpenAPI acessível e atualizada.
- "docker compose up" sobe app+db localmente; migrações aplicadas.
- Deploy no cluster 192.168.1.112 operacional com pelo menos 2 réplicas e probes OK.

## Próximos passos
1) Stack definida: Python (FastAPI) + SQLAlchemy + MySQL. Criar esqueleto do projeto.
2) Modelagem de dados no SQLAlchemy; criar repositórios e casos de uso.
3) Desenhar OpenAPI e expor Swagger UI (FastAPI fornece automaticamente).
4) Implementar endpoints e testes básicos.
5) Criar Dockerfile, .dockerignore e docker-compose.yml (app + MySQL).
6) Escrever manifests Kubernetes (MySQL StatefulSet, API Deployment/Service/ConfigMap/Secrets/Ingress opcional).
7) Configurar GitHub Actions para build/push (Docker Hub) e deploy (Kubernetes), usando secrets.
8) Atualizar README e gravar vídeo demo.

Notas finais:
- Não commitar credenciais do cluster (usuário/senha). Armazenar exclusivamente em secrets do GitHub e/ou ferramentas seguras.
- Se o provedor de pagamento exigir autenticação/assinatura no webhook, incluir validação de HMAC/cabeçalho.
